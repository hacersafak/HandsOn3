# -*- coding: utf-8 -*-
"""2423457-Hacer≈ûafak-HandsOn3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Xkr3M4mgH8Ll8oN3wMEmwVxFN5ikCnJ
"""

!pip install qiskit
!pip install qiskit-Aer
!pip install matplotlib
!pip install pylatexenc
!pip install qiskit-ibm-runtime
!pip install kaleidoscope

# 2. Measure the Bloch sphere coordinates of a qubit using the Aer simulator and plot the vector on the Bloch sphere.
#Step A. Create a qubit state using the circuit method, initialize with two random complex numbers as the parameter.

from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer
import numpy as np

# Creating circuits with complex parameters and normalizing them

def complex_generator():

    random_complex_numbers = [complex(np.random.rand(), np.random.rand()) for _ in range(2)]
    norm = np.sqrt(sum(abs(c)**2 for c in random_complex_numbers))
    normalized_state = [c / norm for c in random_complex_numbers]
    return normalized_state

state=complex_generator()

qc = QuantumCircuit(1, 1)
qc.initialize(state,0)

#Step B. Build the circuits to measure the expectation values of  X,Y,Z  gate based on your answers to the question 1.

# z measurement of qubit 0
measure_z = QuantumCircuit(1,1)
measure_z.measure(0,0)

# x measurement of qubit 0

measure_x=state
measure_x = QuantumCircuit(1,1)
measure_x.h(0)
measure_x.measure(0,0)


# y measurement of qubit 0
measure_y=state
measure_y = QuantumCircuit(1,1)

measure_y.h(0)
measure_y.s(0)
measure_y.measure(0,0)


shots = 2**14 # number of samples used for statistics
sim = Aer.get_backend('aer_simulator')
bloch_vector_measure = []
for measure_circuit in [measure_x, measure_y, measure_z]:

    # run the circuit with the selected measurement and get the number of samples that output each bit value
    circ_trans = transpile(qc.compose(measure_circuit), sim)
    counts = sim.run(qc.compose(circ_trans), shots=shots).result().get_counts()

    # calculate the probabilities for each bit value
    probs = {}
    for output in ['0','1']:
        if output in counts:
            probs[output] = counts[output]/shots
        else:
            probs[output] = 0

    bloch_vector_measure.append( probs['0'] -  probs['1'] )

# normalizing the Bloch sphere vector
bloch_vector = bloch_vector_measure/np.linalg.norm(bloch_vector_measure)

print('The Bloch sphere coordinates are [{0:4.3f}, {1:4.3f}, {2:4.3f}]'
      .format(*bloch_vector))

from kaleidoscope.interactive import bloch_sphere

bloch_sphere(bloch_vector, vectors_annotation=True)

from qiskit.visualization import plot_bloch_vector

plot_bloch_vector( bloch_vector )

#Part 2: Measuring Energy
#Step A. Construct the circuits to prepare four different bell states.

# circuit for the state Tri1
Tri1 = QuantumCircuit(2, 2)
Tri1.initialize([1/np.sqrt(2),0,0,1/np.sqrt(2)])

# circuit for the state Tri2
Tri2 = QuantumCircuit(2, 2)
Tri2.initialize([1/np.sqrt(2),0,0,-1/np.sqrt(2)])

# circuit for the state Tri3
Tri3 = QuantumCircuit(2, 2)
Tri3.initialize([0,1/np.sqrt(2),1/np.sqrt(2),0])

# circuit for the state Sing
Sing = QuantumCircuit(2, 2)
Sing.initialize([0,1/np.sqrt(2),-1/np.sqrt(2),0])

#Step B. Create the circuits to measure the expectation value of each term in the Hamiltonian based on your answer to the question 1.
# <ZZ>
measure_ZZ = QuantumCircuit(2)
measure_ZZ.measure_all()

# <XX>
measure_XX = QuantumCircuit(2)
measure_XX.h(0)
measure_XX.h(1)
measure_XX.measure_all()

# <YY>
measure_YY = QuantumCircuit(2)
measure_YY.sdg(0)
measure_YY.sdg(1)
measure_YY.h(0)
measure_YY.h(1)
measure_YY.measure_all()

#Step C. Execute the circuits on Aer simulator by running the cell below and evaluate the energy expectation value for each state.

shots = 2**14 # number of samples used for statistics

A = 1.47e-6 #unit of A is eV
E_sim = []
for state_init in [Tri1,Tri2,Tri3,Sing]:
    Energy_meas = []
    for measure_circuit in [measure_XX, measure_YY, measure_ZZ]:

        # run the circuit with the selected measurement and get the number of samples that output each bit value
        qc = state_init.compose(measure_circuit)
        qc_trans = transpile(qc, sim)
        counts = sim.run(qc_trans, shots=shots).result().get_counts()

        # calculate the probabilities for each computational basis
        probs = {}
        for output in ['00','01', '10', '11']:
            if output in counts:
                probs[output] = counts[output]/shots
            else:
                probs[output] = 0

        Energy_meas.append( probs['00'] - probs['01'] - probs['10'] + probs['11'] )

    E_sim.append(A * np.sum(np.array(Energy_meas)))

# Run this cell to print out your results

print('Energy expectation value of the state Tri1 : {:.3e} eV'.format(E_sim[0]))
print('Energy expectation value of the state Tri2 : {:.3e} eV'.format(E_sim[1]))
print('Energy expectation value of the state Tri3 : {:.3e} eV'.format(E_sim[2]))
print('Energy expectation value of the state Sing : {:.3e} eV'.format(E_sim[3]))

#Step D. Understanding the result.
# reduced plank constant in (eV) and the speed of light(cgs units)
hbar, c = 4.1357e-15, 3e10

# energy difference between the triplets and singlet
E_del = abs(E_sim[0] - E_sim[3])

# frequency associated with the energy difference
f = E_del/hbar

# convert frequency to wavelength in (cm)
wavelength = c/f

print('The wavelength of the radiation from the transition\
 in the hyperfine structure is : {:.1f} cm'.format(wavelength))